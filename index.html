<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Voice Assistant — Auto Start (No Button)</title>

    <style>
      body {
        height: 100vh;
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #fff;
        color: #000;
        font-family: system-ui;
      }

      .col {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }

      #circle {
        width: 180px;
        height: 180px;
        border-radius: 50%;
        background: #000;
        transform: scale(1);
        transition: transform 120ms linear;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.06);
        margin-bottom: 60px;
        transform-origin: center center;
      }

      #label {
        font-size: 20px;
        color: #333;
      }

      audio {
        display: none;
      }
    </style>
  </head>

  <body>
    <div class="col">
      <div id="circle" aria-hidden="true"></div>
      <div id="label">Starting…</div>
    </div>

    <audio id="audioOutput" autoplay></audio>

    <script>
      const AUTO_START = true; // auto start enabled
      const RTC_CONFIG = __RTC_CONFIGURATION__;

      const circle = document.getElementById("circle");
      const label = document.getElementById("label");
      const audioOutput = document.getElementById("audioOutput");

      let pc = null,
        webrtc_id = null;
      let ac = null,
        analyser_in = null,
        analyser_out = null;
      let data_in = null,
        data_out = null;
      let raf_in = null,
        raf_out = null;
      let micLevel = 0,
        remoteLevel = 0,
        smooth = 1;

      const SMOOTH = 0.18;

      function setLabel(txt) {
        label.textContent = txt;
      }

      function setUI() {
        if (pc && (pc.connectionState === "connecting" || pc.connectionState === "new")) {
          setLabel("Connecting…");
        } else if (pc && pc.connectionState === "connected") {
          setLabel("Connected — listening");
        } else {
          setLabel("Listening (auto)");
        }
      }

      function avg(arr) {
        if (!arr || !arr.length) return 0;
        let s = 0;
        for (let i = 0; i < arr.length; i++) s += arr[i];
        return s / arr.length;
      }

      function monitorMic() {
        if (!analyser_in || !data_in) return;
        analyser_in.getByteFrequencyData(data_in);
        micLevel = Math.min(1, Math.max(0, avg(data_in) / 255));
        raf_in = requestAnimationFrame(monitorMic);
      }

      function visualizeRemote() {
        if (!analyser_out || !data_out) return;
        analyser_out.getByteFrequencyData(data_out);
        remoteLevel = Math.min(1, Math.max(0, avg(data_out) / 255));
        const active = Math.max(remoteLevel, micLevel);
        const target = 1 + active * 1.6;
        smooth = smooth * (1 - SMOOTH) + target * SMOOTH;
        circle.style.transform = `scale(${smooth.toFixed(3)})`;
        raf_out = requestAnimationFrame(visualizeRemote);
      }

      async function setupWebRTC() {
        pc = new RTCPeerConnection(RTC_CONFIG);
        setUI();

        const slow = setTimeout(() => setLabel("Connection taking longer than usual"), 5000);

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

          ac = new (window.AudioContext || window.webkitAudioContext)();
          analyser_in = ac.createAnalyser();
          analyser_in.fftSize = 64;
          data_in = new Uint8Array(analyser_in.frequencyBinCount);

          const inSrc = ac.createMediaStreamSource(stream);
          inSrc.connect(analyser_in);
          if (!raf_in) monitorMic();

          stream.getTracks().forEach((t) => pc.addTrack(t, stream));

          pc.addEventListener("track", (evt) => {
            if (audioOutput.srcObject !== evt.streams[0]) {
              audioOutput.srcObject = evt.streams[0];
              audioOutput.play().catch(() => {});

              analyser_out = ac.createAnalyser();
              analyser_out.fftSize = 2048;
              data_out = new Uint8Array(analyser_out.frequencyBinCount);

              const outSrc = ac.createMediaStreamSource(evt.streams[0]);
              outSrc.connect(analyser_out);

              if (raf_out) cancelAnimationFrame(raf_out);
              raf_out = requestAnimationFrame(visualizeRemote);
            }
          });

          const dc = pc.createDataChannel("text");
          dc.onmessage = (e) => {
            try {
              const j = JSON.parse(e.data);
              if (j.type === "error") setLabel(j.message);
            } catch {}
          };

          pc.addEventListener("connectionstatechange", () => {
            clearTimeout(slow);
            setUI();
          });

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          await new Promise((resolve) => {
            if (pc.iceGatheringState === "complete") return resolve();
            const cb = () => {
              if (pc.iceGatheringState === "complete") {
                pc.removeEventListener("icegatheringstatechange", cb);
                resolve();
              }
            };
            pc.addEventListener("icegatheringstatechange", cb);
          });

          webrtc_id = Math.random().toString(36).slice(2, 9);
          const res = await fetch("/webrtc/offer", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              sdp: pc.localDescription.sdp,
              type: pc.localDescription.type,
              webrtc_id,
            }),
          });

          const serverResp = await res.json();

          if (serverResp.status === "failed") {
            setLabel(serverResp.meta.error || "Failed");
            stop();
            return;
          }

          await pc.setRemoteDescription(serverResp);
        } catch (err) {
          console.error(err);
          setLabel("Failed to establish connection");
          stop();
        }

        setUI();
      }

      function stop() {
        if (raf_in) cancelAnimationFrame(raf_in), (raf_in = null);
        if (raf_out) cancelAnimationFrame(raf_out), (raf_out = null);

        try {
          pc &&
            pc.getSenders &&
            pc.getSenders().forEach((s) => s.track && s.track.stop && s.track.stop());
          pc && pc.close();
        } catch {}

        try {
          ac && ac.close();
        } catch {}

        pc = null;
        ac = null;
        analyser_in = null;
        analyser_out = null;
        data_in = null;
        data_out = null;
        micLevel = 0;
        remoteLevel = 0;
        smooth = 1;
        circle.style.transform = "scale(1)";
        setUI();
      }

      // auto start on load
      if (AUTO_START) setupWebRTC();
      setUI();
    </script>
  </body>
</html>
